; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=aarch64 < %s | FileCheck %s

; Test DAGCombiner optimizations that can bypass NoSignedZerosFPMath requirement
; by using isKnownNeverZeroFloat analysis.

; ===== Test 1: fsub A, 0 -> A =====
; When A is known to be non-zero, we can eliminate the subtraction

define double @fsub_nonzero_minus_zero(double %x) {
; CHECK-LABEL: fsub_nonzero_minus_zero:
; CHECK:       // %bb.0:
; CHECK-NEXT:    fmov d1, #1.00000000
; CHECK-NEXT:    fadd d0, d0, d1
; CHECK-NEXT:    ret
  %add = fadd double %x, 1.0
  %sub = fsub double %add, 0.0
  ret double %sub
}

; ===== Test 2: fneg(fsub(A, B)) -> fsub(B, A) =====
; When A or B is known to be non-zero, we can swap the operands

define double @fneg_fsub_nonzero_nonzero(double %x) {
; CHECK-LABEL: fneg_fsub_nonzero_nonzero:
; CHECK:       // %bb.0:
; CHECK-NEXT:    fmov d1, #1.00000000
; CHECK-NEXT:    fadd d0, d0, d1
; CHECK-NEXT:    fmov d1, #2.00000000
; CHECK-NEXT:    fsub d0, d1, d0
; CHECK-NEXT:    ret
  %add = fadd double %x, 1.0
  %sub = fsub double %add, 2.0
  %neg = fneg double %sub
  ret double %neg
}

; Negative test: both could be same value, can't optimize
define double @fneg_fsub_maybe_equal(double %x, double %y) {
; CHECK-LABEL: fneg_fsub_maybe_equal:
; CHECK:       // %bb.0:
; CHECK-NEXT:    fsub d0, d0, d1
; CHECK-NEXT:    fneg d0, d0
; CHECK-NEXT:    ret
  %sub = fsub double %x, %y
  %neg = fneg double %sub
  ret double %neg
}
